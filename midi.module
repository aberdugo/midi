<?php

/**
 * @file
 * Midi File Module
 * A block module that diplays a midi-box for using Drupal File API to load a midi file.
 */

/**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path
 *   Which path of the site we're using to display help
 * @param arg
 *   Array that holds the current path as returned from arg() function
 */
function midi_help($path, $arg) {
  switch ($path) {
    case "admin/help#midi":
      return t("Displays a midi-box to load a midi file.");
      break;
  }
}

/*
 * Vamos a crear el bloque midi-box
 */

/**
 * Implements hook_block_info().
 *
 * La función hook_block_info() no tiene parámetros de entrada.
 * Devuelve un vector asociativo con la definición del bloque.
 */
function midi_block_info() {
  // Declaración del bloque
  $blocks['midi_block'] = array(
    // The name tha will appear in the block list.
    'info' => t('Midi box'), // info (obligatorio) - Nombre del bloque que aparecerá en el listado de bloques de administración. (Estructura/Bloques)
    'status' => 1, // status (opcional) - Valor inicial de estado del bloque (1 = habilitado, 0 = deshabilitado).
    'weight' => 0, // weight (opcional) - Valor inicial del peso de ordenación del bloque.
    'region' => 'highlighted', // region (opcional) - Valor inicial de la región en la que se muestra el bloque. Si el tema no dispone de la región indicada, el bloque se mostrará deshabilitado. // highlighted - Destacado.
    'visibility' => BLOCK_VISIBILITY_LISTED, // visibility (opcional) - Valor inicial de visibilidad del bloque. // BLOCK_VISIBILITY_LISTED - Se muestra sólo en las páginas indicadas.
    'pages' => '<front>', // pages (opcional) - Listado de URLs o código PHP relacionado con la opción visibility. // <front>
    'cache' => DRUPAL_CACHE_PER_ROLE, // cache (opcional) - Define el tipo de caché. // DRUPAL_CACHE_PER_ROLE (predeterminada) - El bloque puede cambiar en función de los roles del usuario que visita la página.
  );

  return $blocks;
}

/**
 * Implements hook_theme().
 *
 * Creamos el elemento midi_box al que le vamos a asignar la plantilla midi-box.
 */
function midi_theme($existing, $type, $theme, $path) {
  return array(
    'midi_box' => array(
      'template' => 'midi-box',
      'variables' => array(),
    ),
  );
}

/**
 * Implements hook_block_view().
 *
 * Prepares the contents of the block.
 */
function midi_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'midi_block':
      if (user_access('view block midi block')) {
        $block['subject'] = t('Mi primer bloque midi'); // Indicamos el título predeterminado del bloque. Si el bloque no tiene un título predeterminado, debemos indicar NULL.
        $path = drupal_get_path('module', 'midi');
        $block['content'] = array( // El contenido del cuerpo del bloque. Esto deberá ser un vector renderizado (preferiblamente) o una cadena renderizada con contenido HTML.
          /*'part1' => array(
            '#markup' =>  midi_fileload_get_form(),
          ),*/
          'part2' => array(
            '#markup' =>  midi_savefile_get_form(),
          ),
          'part3' => array(
            '#theme' => 'midi_box',
            // '#markup' => theme('midi_box'), // t('Put here the form if could be.');
          ),
          '#attached' => array(
            'css' => array( // Agrega una hoja de estilos en cascada a la cola de la hoja de estilos.
              $path . '/css/midi-box.css',
            ),
            'js' => array( // Agrega un archivo JavaScript, configuración o código en línea a la página.
              $path . '/js/p5.js',
              $path . '/js/p5.dom.js',
              $path . '/js/p5.sound.js',
              $path . '/js/sketch.js',
              array(
                'data' => array('midi_module_path' => $path),
                'type' => 'setting',),
            ),
          ),
        );
      }
      break;
  }
  return $block;
}

/**
 * Implements hook_permission().
 */
function midi_permission() {
  return array(
    'view block midi block' => array(
      'title' => t('View block: Midi box'),
      'description' => t('View the Midi box block.'),
    ),
  );
}


/**
 *  Form constructor for the midi_fileload_form.
 */
function midi_fileload_form($form, &$form_state) {
  $form['file'] = array(
    '#type' => 'file',
    '#title' => t('Midi file'),
    '#description' => t('Upload a midi file, allowed extension: mid'),
  );

  $form['submitLoad'] = array(
    '#type' => 'submit',
    '#value' => t('Load Midi'),
  );

  return $form;
}


function midi_fileload_get_form() {
  $form = drupal_get_form('midi_fileload_form');
  $output = drupal_render($form);

  return $output;
}


/**
 * Validate handler for midi_fileload_form().
 *
 * @ingroup form_example
 */

function midi_fileload_form_validate($form, &$form_state) {
  $file = file_save_upload('file', array(
    // Validate extensions.
    'file_validate_extensions' => array('mid'),
  ), FALSE,
    FILE_EXISTS_REPLACE);
  // If the file passed validation:
  if ($file) {
    $form_state['storage']['file'] = $file;
  }
  else {
    form_set_error('file', t('No file was uploaded.'));
  }
}

/**
 * Submit handler for midi_fileload_form().
 *
 * @ingroup form_example
 */
function midi_fileload_form_submit($form, &$form_state) {
  $file = $form_state['storage']['file'];
  /*
  // We are done with the file, remove it from storage.
  unset($form_state['storage']['file']);
  // Make the storage of the file permanent.
  $file->status = FILE_STATUS_PERMANENT;
  // Save file status.
  file_save($file);
  */
  // Set a response to the user.
  drupal_set_message(t('The form has been submitted and the midi file has been saved temporarily, filename: @filename.', array('@filename' => $file->filename)));
}


/**
 *  Form constructor for the midi_savefile_form.
 */
function midi_savefile_form($form, &$form_state) {
  $form['msg'] = array(
    '#type' => 'markup',
    '#prefix' => '<div id="msg">',
    '#suffix' => '</div>',
  );

  $form['miditext'] = array(
    '#type' => 'textarea',
    '#title' => t(' Midi text '),
    '#required' => TRUE,
  );

  $form['submitCreate'] = array(
    '#type' => 'submit',
    '#value' => t('Save Midi file'),
    '#ajax' => array(
      'callback' => 'midi_savefile_submit_ajax_callback',
      'wrapper' => 'msg',
    ),
  );

  return $form;
}

function midi_savefile_get_form() {
  $form = drupal_get_form('midi_savefile_form');
  $output = drupal_render($form);

  return $output;
}


/**
 * Callback for save midi to DataBase.
 *
 * Select the 'box' element, change the markup in it, and return it as a
 * renderable array.
 *
 * @return array
 *   Renderable array (the box element)
 */

function midi_savefile_submit_ajax_callback($form, $form_state) {
  // In most cases, it is recommended that you put this logic in form generation
  // rather than the callback. Submit driven forms are an exception, because
  // you may not want to return the form at all.

  $element = $form['msg'];

  $stringMidi = $form_state['values']['miditext'];

  if (!empty($stringMidi)) {
    drupal_set_message(t("Clicked submit ({$form_state['values']['op']}): " . date('c')));
    $element['#markup'] = "Clicked submit ({$form_state['values']['op']}): " . date('c');

    if (strpos($stringMidi, 'MFile') !== false) {
      $midi = new Midi(); // Midi - CONSTRUCTOR // (midi-class.inc)
      $midi->importTxt($stringMidi); // importTxt - import whole MIDI song as text (mf2t-format) // (midi-class.inc)
      // midi_save_mid_file($midi);
      $binaryMidi = $midi->getMid();

      global $user;

      // Insertamos registro en la tabla file_binary_midi
      $result = db_insert('file_binary_midi')
        ->fields(array(
          'uid' => $user->uid,
          'filename' => $user->name . ".mid",
          'bmidistring' => $binaryMidi,
          'filesize' => strlen($binaryMidi),
          'timestamp' => REQUEST_TIME,
        ))
        ->execute();
    }
    else {
      form_set_error('miditext', t('Midi text does not have the correct format.'));
    }
  }

  return $element;
}

/**
 * Implements hook_menu().
 */
function midi_menu() {
  $items = array();
  $items['midi_files'] = array(
    'title' => 'Download Midi Files',
    'description' => 'Download Midi Files (description)',
    'page callback' => 'midi_links_page',
    'access callback' => TRUE, // Función de retorno para determinar si el usuario tiene acceso o no a la página. (user_access() por defecto).
  );
  $items['midi_files/download/%/%'] = array(
    'page callback' => 'midi_filedownload',
    'page arguments' => array(2, 3),
    'access callback' => TRUE, // Función de retorno para determinar si el usuario tiene acceso o no a la página. (user_access() por defecto).
    'type' => MENU_CALLBACK,
  );

  return $items;
}

function midi_links_page() {
  $result = get_midis_user();

  $midi_links = array();

  foreach ($result as $midi_link) {
    $midi_links[] = array(
      'data'=> l($midi_link->filename, 'midi_files/download/' . $midi_link->uid . '/' . $midi_link->fid),
    );
  }

  if(empty($midi_links)) {
    return t("You don't have midis in database.");
  }
  else {
    $output = theme('item_list', array('items' => $midi_links));
    return $output;
  }
}

// function get midis for user
function get_midis_user() {
  global $user;

  // Tomamos registro de la tabla file_binary_midi
  $result = db_select('file_binary_midi', 'm')
    ->fields('m')
    ->condition('uid', $user->uid, '=')
    ->orderBy('filename')
    ->execute();

  return $result;
}

function midi_filedownload($midi_file_uid, $midi_file_fid) {
  global $user;
  $bFileExists = false;

  if (isset($user->name)) {
    $username = $user->name;
  }
  else {
    $username = "Anonymous user";
  }

  if ($user->uid == $midi_file_uid) {
    // Tomamos registro de la tabla file_binary_midi
    $result = db_select('file_binary_midi', 'm')
      ->fields('m')
      ->condition('fid', $midi_file_fid, '=')
      ->execute();

    foreach ($result as $file) {
      $bFileExists = true;
      drupal_add_http_header('Content-length', $file->filesize);
      drupal_add_http_header('Content-type', $file->filemime);
      drupal_add_http_header('Content-Disposition', 'attachment; filename=' . $file->filename);

      print($file->bmidistring);
    }

    if ($bFileExists) {
      drupal_page_footer();
    }
    else {
      drupal_set_message(t("@username, this midi file doesn't exist.", array('@username' => $username)), 'error');
      drupal_goto('<front>');
    }
  }
  else {
    drupal_set_message(t("@username, you don't have access to this midi file.", array('@username' => $username)), 'error');
    drupal_goto('<front>');
  }
}

/*
 * Para traducir los textos de dentro de la función t() (Configuración/REGIONAL E IDIOMA-Traducir interfaz/TRADUCIR)
 */